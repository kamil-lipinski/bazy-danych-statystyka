/* Stwórz funkcje:
1. Zwracającą nazwę pracy dla podanego parametru id, dodaj wyjątek, jeśli taka praca nie istnieje */

CREATE OR REPLACE FUNCTION pobierz_nazwe_pracy (p_id jobs.job_id%TYPE) RETURN jobs.job_title%TYPE
IS
    v_job_title jobs.job_title%TYPE;
BEGIN
    SELECT job_title INTO v_job_title FROM jobs WHERE job_id = p_id;
    RETURN v_job_title;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Praca o podanym ID nie istnieje');
END;

/*TEST - VAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_job_title jobs.job_title%TYPE;
BEGIN
    v_job_title := pobierz_nazwe_pracy('AD_PRES');
    DBMS_OUTPUT.PUT_LINE('Nazwa pracy: ' || v_job_title);
END;

/*TEST - INVAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_job_title jobs.job_title%TYPE;
BEGIN
    v_job_title := pobierz_nazwe_pracy('INVALID_JOB'); -- Provide an invalid job ID
    DBMS_OUTPUT.PUT_LINE('Nazwa pracy: ' || v_job_title);
END;

/* 2. Zwracającą roczne zarobki (wynagrodzenie 12-to miesięczne plus premia jako wynagrodzenie * commission_pct) 
dla pracownika o podanym id */

CREATE OR REPLACE FUNCTION pobierz_roczne_zarobki (p_id employees.employee_id%TYPE) RETURN NUMBER
IS
    v_salary NUMBER;
    v_bonus NUMBER;
BEGIN
    SELECT salary, salary * NVL(commission_pct, 0)
    INTO v_salary, v_bonus FROM employees WHERE employee_id = p_id;
    RETURN (v_salary * 12) + v_bonus;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Pracownik o podanym ID nie istnieje');
END;

/*TEST - VAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_yearly_earnings NUMBER;
BEGIN
    v_yearly_earnings := pobierz_roczne_zarobki(100);
    DBMS_OUTPUT.PUT_LINE('Roczne zarobki: ' || v_yearly_earnings);
END;

/*TEST - INVAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_yearly_earnings NUMBER;
BEGIN
    v_yearly_earnings := pobierz_roczne_zarobki(23523523);
    DBMS_OUTPUT.PUT_LINE('Roczne zarobki: ' || v_yearly_earnings);
END;

/* 3. biorącą w nawias numer kierunkowy z numeru telefonu podanego jako varchar */

CREATE OR REPLACE FUNCTION nawias_numer_kierunkowy (p_numer VARCHAR2) RETURN VARCHAR2
IS
    v_numer VARCHAR2(20);
BEGIN
    v_numer := '(' || SUBSTR(p_numer, 2, 2) || ')' || SUBSTR(p_numer, 4);
    RETURN v_numer;
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_numer VARCHAR2(20);
BEGIN
  v_numer := nawias_numer_kierunkowy('+1234567890');
  DBMS_OUTPUT.PUT_LINE('Numer: ' || v_numer);
END;

/* 4. Dla podanego w parametrze ciągu znaków zmieniającą pierwszą i 
ostatnią literę na wielką – pozostałe na małe */

CREATE OR REPLACE FUNCTION zmien_wielkosc_liter (p_str VARCHAR2) RETURN VARCHAR2
IS
    v_str VARCHAR2(50);
BEGIN
    v_str := UPPER(SUBSTR(p_str, 1, 1)) || LOWER(SUBSTR(p_str, 2, LENGTH(p_str)-2)) || UPPER(SUBSTR(p_str, LENGTH(p_str)));
    RETURN v_str;
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_str VARCHAR2(50);
BEGIN
  v_str := zmien_wielkosc_liter('aNaNas');
  DBMS_OUTPUT.PUT_LINE(v_str);
END;

/* 5. Dla podanego peselu - przerabiającą pesel na datę urodzenia w formacie ‘yyyy-mm-dd’ */
CREATE OR REPLACE FUNCTION pesel_na_date (p_pesel VARCHAR2) RETURN VARCHAR2
IS
    v_rok VARCHAR2(4);
    v_miesiac VARCHAR2(2);
    v_dzien VARCHAR2(2);
BEGIN
    IF LENGTH(p_pesel) = 11 THEN
        v_rok := SUBSTR(p_pesel, 1, 2);
        v_miesiac := SUBSTR(p_pesel, 3, 2);
        v_dzien := SUBSTR(p_pesel, 5, 2);

        IF TO_NUMBER(v_miesiac) > 12 THEN
            v_rok := '20' || v_rok;
            v_miesiac := TO_CHAR(TO_NUMBER(v_miesiac) - 20);
        ELSE
            v_rok := '19' || v_rok;
        END IF;

        RETURN v_rok || '-' || v_miesiac || '-' || v_dzien;
    ELSE
        RAISE_APPLICATION_ERROR(-20003, 'Nieprawidłowy format PESEL.');
    END IF;
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_data_ur VARCHAR2(10);
BEGIN
  v_data_ur := pesel_na_date('00242404451');
  DBMS_OUTPUT.PUT_LINE('Data urodzenia: ' || v_data_ur);
END;

/* 6. Zwracającą liczbę pracowników oraz liczbę departamentów które znajdują się 
w kraju podanym jako parametr (nazwa kraju). W przypadku braku kraju - odpowiedni wyjątek */

CREATE OR REPLACE FUNCTION liczba_pracownikow_i_departamentow(p_country_name countries.country_name%TYPE) RETURN VARCHAR2
IS
    v_liczba_pracownikow NUMBER;
    v_liczba_departamentow NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_liczba_pracownikow FROM employees
    JOIN departments ON employees.department_id = departments.department_id
    JOIN locations ON departments.location_id = locations.location_id
    JOIN countries ON locations.country_id = countries.country_id
    WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
    SELECT COUNT(*) INTO v_liczba_departamentow FROM departments
    JOIN locations ON departments.location_id = locations.location_id
    JOIN countries ON locations.country_id = countries.country_id
    WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
    RETURN 'Liczba pracowników: ' || v_liczba_pracownikow || ', Liczba departamentów: ' || v_liczba_departamentow;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Brak kraju o podanej nazwie');
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_wynik VARCHAR2(100);
BEGIN
  v_wynik := liczba_pracownikow_i_departamentow('united states of america');
  DBMS_OUTPUT.PUT_LINE(v_wynik);
END;

/* =========================
Stworzyć następujące wyzwalacze:
1. Stworzyć tabelę archiwum_departamentów (id, nazwa, data_zamknięcia, ostatni_manager jako imię i nazwisko). 
Po usunięciu departamentu dodać odpowiedni rekord do tej tabeli */

CREATE TABLE archiwum_departamentow (id NUMBER PRIMARY KEY, nazwa VARCHAR2(30), 
data_zamkniecia DATE, ostatni_manager VARCHAR2(100));

CREATE OR REPLACE TRIGGER dodaj_do_archiwum_departamentow 
AFTER DELETE ON departments FOR EACH ROW
DECLARE
    v_data_zamkniecia DATE := SYSDATE;
    v_ostatni_manager VARCHAR2(100);
BEGIN
    SELECT first_name || last_name INTO v_ostatni_manager FROM employees
    WHERE employee_id = :OLD.manager_id;
    INSERT INTO archiwum_departamentow (id, nazwa, data_zamkniecia, ostatni_manager)
    VALUES (:OLD.department_id, :OLD.department_name, v_data_zamkniecia, v_ostatni_manager);
END;

/* TEST */
DELETE FROM departments WHERE department_id = 10;
SELECT * FROM archiwum_departamentow;

/* 2. W razie UPDATE i INSERT na tabeli employees, sprawdzić czy zarobki łapią się 
w widełkach 2000 - 26000. Jeśli nie łapią się - zabronić dodania. 
Dodać tabelę złodziej(id, USER, czas_zmiany), której będą wrzucane logi, 
jeśli będzie próba dodania, bądź zmiany wynagrodzenia poza widełki. */

CREATE TABLE zlodziej (id NUMBER PRIMARY KEY, username VARCHAR2(100), czas_zmiany DATE);

CREATE SEQUENCE zlodziej_seq START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER sprawdz_widelki
BEFORE INSERT OR UPDATE OF salary ON employees FOR EACH ROW 
DECLARE
    v_id NUMBER;
BEGIN
    IF :NEW.salary < 2000 OR :NEW.salary > 26000 THEN
        :NEW.salary := :OLD.salary;
        INSERT INTO zlodziej (id, username, czas_zmiany)
        VALUES (zlodziej_seq.NEXTVAL, USER, SYSDATE);
    END IF;
END;

/* TEST */
UPDATE employees SET salary = 300000 WHERE employee_id = 101;
SELECT * FROM zlodziej;
SELECT * FROM employees;

/* 3. Stworzyć sekwencję i wyzwalacz, który będzie odpowiadał za auto_increment 
w tabeli employees. */

CREATE SEQUENCE employees_seq START WITH 207 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER employees_auto_increment
BEFORE INSERT ON employees FOR EACH ROW
BEGIN
    SELECT employees_seq.NEXTVAL INTO :NEW.employee_id FROM DUAL;
END;

ALTER TABLE employees MODIFY (employee_id DEFAULT employees_seq.NEXTVAL);

/* TEST */
INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary)
VALUES ('Jan', 'Kowalski', 'jan@wp.pl', SYSDATE, 'IT_PROG', 5000);

SELECT * FROM employees;

/* 4. Stworzyć wyzwalacz, który zabroni dowolnej operacji na tabeli 
JOD_GRADES (INSERT, UPDATE, DELETE) */

CREATE OR REPLACE TRIGGER zabron_operacji_job_grades
BEFORE INSERT OR UPDATE OR DELETE ON job_grades FOR EACH ROW
BEGIN
    RAISE_APPLICATION_ERROR(-20001, 'Operacje na tabeli JOD_GRADES są zabronione');
END;

/* TEST */
DELETE FROM job_grades WHERE grade = 'A';

/* 5. Stworzyć wyzwalacz, który przy próbie zmiany max i min salary w tabeli 
jobs zostawia stare wartości. */

CREATE OR REPLACE TRIGGER zabron_zmiany_salary
BEFORE UPDATE OF max_salary, min_salary ON jobs
FOR EACH ROW
BEGIN
    :NEW.max_salary := :OLD.max_salary;
    :NEW.min_salary := :OLD.min_salary;
END;

/* TEST */
UPDATE jobs SET max_salary = 99999, min_salary = 1111 WHERE job_id = 'AD_PRES';
SELECT * FROM jobs WHERE job_id = 'AD_PRES';

/* Stworzyć paczki:
1. Składającą się ze stworzonych procedur i funkcji */

CREATE OR REPLACE PACKAGE paczka_1 AS
    FUNCTION liczba_pracownikow_i_departamentow(p_country_name countries.country_name%TYPE) RETURN VARCHAR2;
    FUNCTION liczba_pracownikow_i_departamentow_w_kraju (p_country_name countries.country_name%TYPE) RETURN VARCHAR2;
    FUNCTION nawias_numer_kierunkowy (p_numer VARCHAR2) RETURN VARCHAR2;
    FUNCTION pesel_na_date (p_pesel VARCHAR2) RETURN VARCHAR2;
    FUNCTION pobierz_nazwe_pracy (p_id jobs.job_id%TYPE) RETURN VARCHAR2;
    FUNCTION pobierz_numer_kierunkowy (p_numer VARCHAR2) RETURN VARCHAR2;
    FUNCTION pobierz_roczne_zarobki (p_id employees.employee_id%TYPE) RETURN NUMBER;
    FUNCTION zmien_wielkosc_liter (p_str VARCHAR2) RETURN VARCHAR2;
END paczka_1;
/
CREATE OR REPLACE PACKAGE BODY paczka_1 AS
    FUNCTION liczba_pracownikow_i_departamentow(p_country_name countries.country_name%TYPE) RETURN VARCHAR2
    IS
        v_liczba_pracownikow NUMBER;
        v_liczba_departamentow NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_liczba_pracownikow FROM employees
        JOIN departments ON employees.department_id = departments.department_id
        JOIN locations ON departments.location_id = locations.location_id
        JOIN countries ON locations.country_id = countries.country_id
        WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
        SELECT COUNT(*) INTO v_liczba_departamentow FROM departments
        JOIN locations ON departments.location_id = locations.location_id
        JOIN countries ON locations.country_id = countries.country_id
        WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
        RETURN 'Liczba pracowników: ' || v_liczba_pracownikow || ', Liczba departamentów: ' || v_liczba_departamentow;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'Brak kraju o podanej nazwie');
    END liczba_pracownikow_i_departamentow;
    
    FUNCTION liczba_pracownikow_i_departamentow_w_kraju (p_country_name countries.country_name%TYPE) RETURN VARCHAR2
    IS
        v_liczba_pracownikow NUMBER;
        /*v_liczba_departamentow NUMBER;*/
    BEGIN
        SELECT COUNT(*) INTO v_liczba_pracownikow FROM employees
        JOIN departments ON employees.department_id = departments.department_id
        JOIN locations ON departments.location_id = locations.location_id
        JOIN countries ON locations.country_id = countries.country_id
        WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
        RETURN 'Liczba pracowników: ' || v_liczba_pracownikow;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'Brak kraju o podanej nazwie');
    END liczba_pracownikow_i_departamentow_w_kraju;
    
    FUNCTION nawias_numer_kierunkowy (p_numer VARCHAR2) RETURN VARCHAR2
    IS
        v_numer VARCHAR2(20);
    BEGIN
        v_numer := '(' || SUBSTR(p_numer, 2, 2) || ')' || SUBSTR(p_numer, 4);
        RETURN v_numer;
    END nawias_numer_kierunkowy;
    
    FUNCTION pesel_na_date (p_pesel VARCHAR2) RETURN VARCHAR2
    IS
        v_rok VARCHAR2(4);
        v_miesiac VARCHAR2(2);
        v_dzien VARCHAR2(2);
    BEGIN
        IF LENGTH(p_pesel) = 11 THEN
            v_rok := SUBSTR(p_pesel, 1, 2);
            v_miesiac := SUBSTR(p_pesel, 3, 2);
            v_dzien := SUBSTR(p_pesel, 5, 2);
    
            IF TO_NUMBER(v_miesiac) > 12 THEN
                v_rok := '20' || v_rok;
                v_miesiac := TO_CHAR(TO_NUMBER(v_miesiac) - 20);
            ELSE
                v_rok := '19' || v_rok;
            END IF;
    
            RETURN v_rok || '-' || v_miesiac || '-' || v_dzien;
        ELSE
            RAISE_APPLICATION_ERROR(-20003, 'Nieprawidłowy format PESEL.');
        END IF;
    END pesel_na_date;
    
    FUNCTION pobierz_nazwe_pracy (p_id jobs.job_id%TYPE) RETURN jobs.job_title%TYPE
    IS
        v_job_title jobs.job_title%TYPE;
    BEGIN
        SELECT job_title INTO v_job_title FROM jobs WHERE job_id = p_id;
        RETURN v_job_title;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'Praca o podanym ID nie istnieje');
    END pobierz_nazwe_pracy;
    
    FUNCTION pobierz_numer_kierunkowy (p_numer VARCHAR2) RETURN VARCHAR2
    IS
      v_numer_kierunkowy VARCHAR2(10);
    BEGIN
      IF LENGTH(p_numer) >= 10 THEN
        v_numer_kierunkowy := SUBSTR(p_numer, 1, 3);
        RETURN v_numer_kierunkowy;
      ELSE
        RAISE_APPLICATION_ERROR(-20002, 'Nieprawidłowy format numeru telefonu.');
      END IF;
    END pobierz_numer_kierunkowy;
    
    FUNCTION pobierz_roczne_zarobki (p_id employees.employee_id%TYPE) RETURN NUMBER
    IS
        v_salary NUMBER;
        v_bonus NUMBER;
    BEGIN
        SELECT salary, salary * NVL(commission_pct, 0)
        INTO v_salary, v_bonus FROM employees WHERE employee_id = p_id;
        RETURN (v_salary * 12) + v_bonus;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'Pracownik o podanym ID nie istnieje');
    END pobierz_roczne_zarobki;
    
    FUNCTION zmien_wielkosc_liter (p_str VARCHAR2) RETURN VARCHAR2
    IS
        v_str VARCHAR2(50);
    BEGIN
        v_str := UPPER(SUBSTR(p_str, 1, 1)) || LOWER(SUBSTR(p_str, 2, LENGTH(p_str)-2)) || UPPER(SUBSTR(p_str, LENGTH(p_str)));
        RETURN v_str;
    END zmien_wielkosc_liter;
END paczka_1;



/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_wynik VARCHAR2(100);
BEGIN
  v_wynik := paczka_1.liczba_pracownikow_i_departamentow('united states of america');
  DBMS_OUTPUT.PUT_LINE(v_wynik);
END;




















