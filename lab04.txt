/* Stwórz funkcje:
1. Zwracającą nazwę pracy dla podanego parametru id, dodaj wyjątek, jeśli taka praca nie istnieje */

CREATE OR REPLACE FUNCTION pobierz_nazwe_pracy (p_id jobs.job_id%TYPE) RETURN jobs.job_title%TYPE
IS
    v_job_title jobs.job_title%TYPE;
BEGIN
    SELECT job_title INTO v_job_title FROM jobs WHERE job_id = p_id;
    RETURN v_job_title;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Praca o podanym ID nie istnieje');
END;

/*TEST - VAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_job_title jobs.job_title%TYPE;
BEGIN
    v_job_title := pobierz_nazwe_pracy('AD_PRES');
    DBMS_OUTPUT.PUT_LINE('Nazwa pracy: ' || v_job_title);
END;

/*TEST - INVAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_job_title jobs.job_title%TYPE;
BEGIN
    v_job_title := pobierz_nazwe_pracy('INVALID_JOB'); -- Provide an invalid job ID
    DBMS_OUTPUT.PUT_LINE('Nazwa pracy: ' || v_job_title);
END;

/* 2. Zwracającą roczne zarobki (wynagrodzenie 12-to miesięczne plus premia jako wynagrodzenie * commission_pct) 
dla pracownika o podanym id */

CREATE OR REPLACE FUNCTION pobierz_roczne_zarobki (p_id employees.employee_id%TYPE) RETURN NUMBER
IS
    v_salary NUMBER;
    v_bonus NUMBER;
BEGIN
    SELECT salary, salary * NVL(commission_pct, 0)
    INTO v_salary, v_bonus FROM employees WHERE employee_id = p_id;
    RETURN (v_salary * 12) + v_bonus;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Pracownik o podanym ID nie istnieje');
END;

/*TEST - VAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_yearly_earnings NUMBER;
BEGIN
    v_yearly_earnings := pobierz_roczne_zarobki(100);
    DBMS_OUTPUT.PUT_LINE('Roczne zarobki: ' || v_yearly_earnings);
END;

/*TEST - INVAlID ID*/
SET SERVEROUTPUT ON;
DECLARE
    v_yearly_earnings NUMBER;
BEGIN
    v_yearly_earnings := pobierz_roczne_zarobki(23523523);
    DBMS_OUTPUT.PUT_LINE('Roczne zarobki: ' || v_yearly_earnings);
END;

/* 3. biorącą w nawias numer kierunkowy z numeru telefonu podanego jako varchar */

CREATE OR REPLACE FUNCTION nawias_numer_kierunkowy (p_numer VARCHAR2) RETURN VARCHAR2
IS
    v_numer VARCHAR2(20);
BEGIN
    v_numer := '(' || SUBSTR(p_numer, 2, 2) || ')' || SUBSTR(p_numer, 4);
    RETURN v_numer;
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_numer VARCHAR2(20);
BEGIN
  v_numer := nawias_numer_kierunkowy('+1234567890');
  DBMS_OUTPUT.PUT_LINE('Numer: ' || v_numer);
END;

/* 4. Dla podanego w parametrze ciągu znaków zmieniającą pierwszą i 
ostatnią literę na wielką – pozostałe na małe */

CREATE OR REPLACE FUNCTION zmien_wielkosc_liter (p_str VARCHAR2) RETURN VARCHAR2
IS
    v_str VARCHAR2(50);
BEGIN
    v_str := UPPER(SUBSTR(p_str, 1, 1)) || LOWER(SUBSTR(p_str, 2, LENGTH(p_str)-2)) || UPPER(SUBSTR(p_str, LENGTH(p_str)));
    RETURN v_str;
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_str VARCHAR2(50);
BEGIN
  v_str := zmien_wielkosc_liter('aNaNas');
  DBMS_OUTPUT.PUT_LINE(v_str);
END;

/* 5. Dla podanego peselu - przerabiającą pesel na datę urodzenia w formacie ‘yyyy-mm-dd’ */
CREATE OR REPLACE FUNCTION pesel_na_date (p_pesel VARCHAR2) RETURN VARCHAR2
IS
    v_rok VARCHAR2(4);
    v_miesiac VARCHAR2(2);
    v_dzien VARCHAR2(2);
BEGIN
    IF LENGTH(p_pesel) = 11 THEN
        v_rok := SUBSTR(p_pesel, 1, 2);
        v_miesiac := SUBSTR(p_pesel, 3, 2);
        v_dzien := SUBSTR(p_pesel, 5, 2);

        IF TO_NUMBER(v_miesiac) > 12 THEN
            v_rok := '20' || v_rok;
            v_miesiac := TO_CHAR(TO_NUMBER(v_miesiac) - 20);
        ELSE
            v_rok := '19' || v_rok;
        END IF;

        RETURN v_rok || '-' || v_miesiac || '-' || v_dzien;
    ELSE
        RAISE_APPLICATION_ERROR(-20003, 'Nieprawidłowy format PESEL.');
    END IF;
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_data_ur VARCHAR2(10);
BEGIN
  v_data_ur := pesel_na_date('00242404451');
  DBMS_OUTPUT.PUT_LINE('Data urodzenia: ' || v_data_ur);
END;

/* 6. Zwracającą liczbę pracowników oraz liczbę departamentów które znajdują się 
w kraju podanym jako parametr (nazwa kraju). W przypadku braku kraju - odpowiedni wyjątek */

CREATE OR REPLACE FUNCTION liczba_pracownikow_i_departamentow(p_country_name countries.country_name%TYPE) RETURN VARCHAR2
IS
    v_liczba_pracownikow NUMBER;
    v_liczba_departamentow NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_liczba_pracownikow FROM employees
    JOIN departments ON employees.department_id = departments.department_id
    JOIN locations ON departments.location_id = locations.location_id
    JOIN countries ON locations.country_id = countries.country_id
    WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
    SELECT COUNT(*) INTO v_liczba_departamentow FROM departments
    JOIN locations ON departments.location_id = locations.location_id
    JOIN countries ON locations.country_id = countries.country_id
    WHERE LOWER(countries.country_name) = LOWER(p_country_name);
    
    RETURN 'Liczba pracowników: ' || v_liczba_pracownikow || ', Liczba departamentów: ' || v_liczba_departamentow;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20001, 'Brak kraju o podanej nazwie');
END;

/* TEST */
SET SERVEROUTPUT ON;
DECLARE
  v_wynik VARCHAR2(100);
BEGIN
  v_wynik := liczba_pracownikow_i_departamentow('united states of america');
  DBMS_OUTPUT.PUT_LINE(v_wynik);
END;

/* =========================
Stworzyć następujące wyzwalacze:
1. Stworzyć tabelę archiwum_departamentów (id, nazwa, data_zamknięcia, ostatni_manager jako imię i nazwisko). 
Po usunięciu departamentu dodać odpowiedni rekord do tej tabeli */

CREATE TABLE archiwum_departamentow (id NUMBER PRIMARY KEY, nazwa VARCHAR2(30), 
data_zamkniecia DATE, ostatni_manager VARCHAR2(100));

CREATE OR REPLACE TRIGGER dodaj_do_archiwum_departamentow 
AFTER DELETE ON departments FOR EACH ROW
DECLARE
    v_data_zamkniecia DATE := SYSDATE;
    v_ostatni_manager VARCHAR2(100);
BEGIN
    SELECT first_name || last_name INTO v_ostatni_manager FROM employees
    WHERE employee_id = :OLD.manager_id;
    INSERT INTO archiwum_departamentow (id, nazwa, data_zamkniecia, ostatni_manager)
    VALUES (:OLD.department_id, :OLD.department_name, v_data_zamkniecia, v_ostatni_manager);
END;

/* TEST */
DELETE FROM departments WHERE department_id = 10;
SELECT * FROM archiwum_departamentow;

/* 2. W razie UPDATE i INSERT na tabeli employees, sprawdzić czy zarobki łapią się 
w widełkach 2000 - 26000. Jeśli nie łapią się - zabronić dodania. 
Dodać tabelę złodziej(id, USER, czas_zmiany), której będą wrzucane logi, 
jeśli będzie próba dodania, bądź zmiany wynagrodzenia poza widełki. */

CREATE TABLE zlodziej (id NUMBER PRIMARY KEY, username VARCHAR2(100), czas_zmiany DATE);

CREATE SEQUENCE zlodziej_seq START WITH 1 INCREMENT BY 1;

    CREATE OR REPLACE TRIGGER sprawdz_widelki
    BEFORE INSERT OR UPDATE OF salary ON employees FOR EACH ROW
    DECLARE
        v_id NUMBER;
    BEGIN
        IF :NEW.salary < 2000 OR :NEW.salary > 26000 THEN
            :NEW.salary := :OLD.salary;
            INSERT INTO zlodziej (id, username, czas_zmiany)
            VALUES (zlodziej_seq.NEXTVAL, USER, SYSDATE);
        END IF;
    END;

/* TEST */
UPDATE employees SET salary = 300000 WHERE employee_id = 101;
SELECT * FROM zlodziej;
SELECT * FROM employees;

/* 3. Stworzyć sekwencję i wyzwalacz, który będzie odpowiadał za auto_increment 
w tabeli employees. */

CREATE SEQUENCE employees_seq START WITH 207 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER employees_auto_increment
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    SELECT employees_seq.NEXTVAL INTO :NEW.employee_id FROM DUAL;
END;

ALTER TABLE employees MODIFY (employee_id DEFAULT employees_seq.NEXTVAL);

/* TEST */
INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary)
VALUES ('Jan', 'Kowalski', 'jan@wp.pl', SYSDATE, 'IT_PROG', 5000);

SELECT * FROM employees;



